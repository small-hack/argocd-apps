# installs mimir
---
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: mimir-appset
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "2"
spec:
  goTemplate: true
  # generator allows us to source specific values from an external secret
  generators:
    - plugin:
        configMapRef:
          name: secret-var-plugin-generator
        input:
          parameters:
            secret_vars:
              - grafana_stack_mimir_hostname
              - zitadel_hostname
              - global_cluster_issuer
  template:
    metadata:
      name: mimir

    spec:
      project: monitoring
      syncPolicy:
        syncOptions:
          - ApplyOutOfSyncOnly=true
        automated:
          selfHeal: true
          prune: true

      # where to deploy this application
      destination:
        server: https://kubernetes.default.svc
        namespace: monitoring

      # where to source this application from
      source:
        # https://github.com/grafana/mimir/tree/main/operations/helm/charts/mimir-distributed
        repoURL: https://grafana.github.io/helm-charts
        chart: mimir-distributed
        targetRevision: 5.8.0-weekly.339-dev.2
        helm:
          releaseName: mimir
          valuesObject:
            fullnameOverride: mimir
            # -- Additional structured values on top of the text based 'mimir.config'. Applied after the text based config is evaluated for templates. Enables adding and modifying YAML elements in the evaulated 'mimir.config'.
            #
            # Additionally, consider the optional "insecure_skip_verify" key below, it allows you to skip_verify_false in case the s3_endpoint certificate is not trusted.
            # For more information see https://grafana.com/docs/mimir/latest/references/configuration-parameters/
            structuredConfig:
              common:
                storage:
                  backend: s3
                  s3:
                    bucket_name: "${BUCKET_NAME}"
                    endpoint: "${BUCKET_HOST}:${BUCKET_PORT}"
                    access_key_id: "${AWS_ACCESS_KEY_ID}" # This is a secret injected via an environment variable
                    secret_access_key: "${AWS_SECRET_ACCESS_KEY}" # This is a secret injected via an environment variable
                    http:
                      insecure_skip_verify: true

            # -- Configuration is loaded from the secret called 'externalConfigSecretName'.
            # If 'useExternalConfig' is true, then the configuration is not generated, just consumed.
            useExternalConfig: false

            # -- Defines what kind of object stores the configuration, a ConfigMap or a Secret.
            # In order to move sensitive information (such as credentials) from
            # the ConfigMap/Secret to a more secure location (e.g. vault),
            # it is possible to use [environment variables in the configuration](https://grafana.com/docs/mimir/latest/reference-configuration-parameters/#use-environment-variables-in-the-configuration).
            # Such environment variables can be then stored in a separate Secret
            # and injected via the global.extraEnvFrom value. For details about
            # environment injection from a Secret please see
            # [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables).
            configStorageType: Secret

            # -- Name of the Secret or ConfigMap that contains the configuration
            # (used for naming even if config is internal).
            # externalConfigSecretName: '{{ include "mimir.resourceName" (dict "ctx" . "component" "config") }}'

            # mimir's ingester
            ingester:
              replicas: 2
              zoneAwareReplication:
                # -- Enable zone-aware replication for ingester
                enabled: false

            # mimir's store_gateway
            store_gateway:
              replicas: 1
              enabled: true
              zoneAwareReplication:
                # -- Enable zone-aware replication for ingester
                enabled: false

            # mimir's forked alertmanager
            alertmanager:
              enabled: true
              replicas: 1

            # -- KEDA Autoscaling configuration
            kedaAutoscaling:
              # -- A Prometheus-compatible URL. Cadvisor and Mimir metrics for the Mimir pods are expected in this server.
              # For more information on the required metrics see [Monitor system health](https://grafana.com/docs/helm-charts/mimir-distributed/latest/run-production-environment-with-helm/monitor-system-health/).
              # If empty, the helm chart uses the metamonitoring URL from metaMonitoring.grafanaAgent.metrics.remote.url.
              # If that is empty, then the Mimir cluster is used.
              prometheusAddress: ""
              customHeaders: {}
              pollingInterval: 10
              ignoreNullValues: true
              unsafeSsl: false

            memcachedExporter:
              # -- Whether memcached metrics should be exported
              # we will use valkey so we don't need this
              enabled: false

            # don't need minio because we provide s3 via seaweedfs
            minio:
              enabled: false
