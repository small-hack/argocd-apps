# installs mimir
---
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: mimir-appset
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "2"
spec:
  goTemplate: true
  # generator allows us to source specific values from an external secret
  generators:
    - plugin:
        configMapRef:
          name: secret-var-plugin-generator
        input:
          parameters:
            secret_vars:
              - grafana_stack_mimir_hostname
              - zitadel_hostname
              - global_cluster_issuer
  template:
    metadata:
      name: mimir

    spec:
      project: monitoring
      syncPolicy:
        syncOptions:
          - ApplyOutOfSyncOnly=true
        automated:
          selfHeal: true
          prune: true

      # where to deploy this application
      destination:
        server: https://kubernetes.default.svc
        namespace: monitoring

      # where to source this application from
      source:
        # https://github.com/grafana/mimir/tree/main/operations/helm/charts/mimir-distributed
        repoURL: https://grafana.github.io/helm-charts
        chart: mimir-distributed
        targetRevision: 5.8.0-weekly.339-dev.2
        helm:
          releaseName: mimir
          valuesObject:
            fullnameOverride: mimir
            image:
              # -- Grafana Mimir container image repository. Note: for Grafana Enterprise Metrics use the value 'enterprise.image.repository'
              repository: grafana/mimir
              # -- Grafana Mimir container image tag. Note: for Grafana Enterprise Metrics use the value 'enterprise.image.tag'
              tag: 2.17.0
              # -- Container pull policy - shared between Grafana Mimir and Grafana Enterprise Metrics
              pullPolicy: IfNotPresent
              # -- Configuration is loaded from the secret called 'externalConfigSecretName'.
              # If 'useExternalConfig' is true, then the configuration is not generated, just consumed.
              useExternalConfig: false

            # -- Defines what kind of object stores the configuration, a ConfigMap or a Secret.
            # In order to move sensitive information (such as credentials) from
            # the ConfigMap/Secret to a more secure location (e.g. vault),
            # it is possible to use [environment variables in the configuration](https://grafana.com/docs/mimir/latest/reference-configuration-parameters/#use-environment-variables-in-the-configuration).
            # Such environment variables can be then stored in a separate Secret
            # and injected via the global.extraEnvFrom value. For details about
            # environment injection from a Secret please see
            # [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/#use-case-as-container-environment-variables).
            configStorageType: Secret

            # -- Name of the Secret or ConfigMap that contains the configuration
            # (used for naming even if config is internal).
            # externalConfigSecretName: '{{ include "mimir.resourceName" (dict "ctx" . "component" "config") }}'

            # mimir's ingester
            ingester:
              #topologySpreadConstraints: []
              replicas: 2
              zoneAwareReplication:
                # -- Enable zone-aware replication for ingester
                enabled: false

            # mimir's store_gateway
            store_gateway:
              #topologySpreadConstraints: []
              replicas: 2
              enabled: true
              zoneAwareReplication:
                # -- Enable zone-aware replication for ingester
                enabled: false

            # mimir's forked alertmanager
            alertmanager:
              #topologySpreadConstraints: []
              enabled: true
              replicÂ§as: 2

            #distributor:
            #  topologySpreadConstraints: []

            #compactor:
            #  topologySpreadConstraints: []

            #ruler:
            #  topologySpreadConstraints: []

            #query_scheduler:
            #  topologySpreadConstraints: []

            #querier:
            #  topologySpreadConstraints: []

            #query_frontend:
            #  topologySpreadConstraints: []

            nginx:
              replicas: 2
              autoscaling:
                enabled: false
                minReplicas: 1
                maxReplicas: 3

              basicAuth:
                enabled: true

              # topologySpreadConstraints: []

              ingress:
                enabled: true
                ingressClassName: nginx
                annotations: {}
                hosts:
                  - host: mimir.vleermuis.tech
                    paths:
                      - path: /
                        pathType: Prefix
                    # -- TLS configuration for the nginx ingress
                    tls:
                      - secretName: mimir-nginx-tls
                        hosts:
                          - mimir.vleermuis.tech

            # -- KEDA Autoscaling configuration
            kedaAutoscaling:
              # -- A Prometheus-compatible URL. Cadvisor and Mimir metrics for the Mimir pods are expected in this server.
              # For more information on the required metrics see [Monitor system health](https://grafana.com/docs/helm-charts/mimir-distributed/latest/run-production-environment-with-helm/monitor-system-health/).
              # If empty, the helm chart uses the metamonitoring URL from metaMonitoring.grafanaAgent.metrics.remote.url.
              # If that is empty, then the Mimir cluster is used.
              prometheusAddress: ""
              customHeaders: {}
              pollingInterval: 10
              ignoreNullValues: true
              unsafeSsl: false

            memcachedExporter:
              # -- Whether memcached metrics should be exported
              # we will use valkey so we don't need this
              enabled: false

            # don't need minio because we provide s3 via seaweedfs
            minio:
              enabled: false
