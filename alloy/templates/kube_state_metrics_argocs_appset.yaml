---
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: kube-state-metrics-appset
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "2"
spec:
  goTemplate: true
  # generator allows us to source specific values from an external secret
  generators:
    - plugin:
        configMapRef:
          name: secret-var-plugin-generator
        input:
          parameters:
            secret_vars:
              - global_cluster_issuer
  template:
    metadata:
      name: kube-state-metrics

    spec:
      project: monitoring
      syncPolicy:
        syncOptions:
          - ApplyOutOfSyncOnly=true
        automated:
          selfHeal: true
          prune: true

      # where to deploy this application
      destination:
        server: https://kubernetes.default.svc
        namespace: monitoring

      # where to source this application from
      source:
        # https://github.com/grafana/alloy/tree/main/operations/helm/charts/alloy
        repoURL: https://prometheus-community.github.io/helm-charts
        chart: kube-state-metrics
        targetRevision: 6.3.0
        helm:
          releaseName: kube-state-metrics
          valuesObject:
            # Default values for kube-state-metrics.
            prometheusScrape: false
            image:
              registry: registry.k8s.io
              repository: kube-state-metrics/kube-state-metrics
              # If unset use v + .Charts.appVersion
              tag: ""
              sha: ""
              pullPolicy: IfNotPresent

            imagePullSecrets: []
            # - name: "image-pull-secret"

            global:
              # To help compatibility with other charts which use global.imagePullSecrets.
              # Allow either an array of {name: pullSecret} maps (k8s-style), or an array of strings (more common helm-style).
              # global:
              #   imagePullSecrets:
              #   - name: pullSecret1
              #   - name: pullSecret2
              # or
              # global:
              #   imagePullSecrets:
              #   - pullSecret1
              #   - pullSecret2
              imagePullSecrets: []
              #
              # Allow parent charts to override registry hostname
              imageRegistry: ""

            # If set to true, this will deploy kube-state-metrics as a StatefulSet and the data
            # will be automatically sharded across <.Values.replicas> pods using the built-in
            # autodiscovery feature: https://github.com/kubernetes/kube-state-metrics#automated-sharding
            # This is an experimental feature and there are no stability guarantees.
            autosharding:
              enabled: false

            replicas: 1

            # Change the deployment strategy when autosharding is disabled.
            # ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
            # The default is "RollingUpdate" as per Kubernetes defaults.
            # During a release, 'RollingUpdate' can lead to two running instances for a short period of time while 'Recreate' can create a small gap in data.
            # updateStrategy: Recreate

            # Number of old history to retain to allow rollback
            # Default Kubernetes value is set to 10
            revisionHistoryLimit: 10

            # List of additional cli arguments to configure kube-state-metrics
            # for example: --enable-gzip-encoding, --log-file, etc.
            # all the possible args can be found here: https://github.com/kubernetes/kube-state-metrics/blob/main/docs/developer/cli-arguments.md
            extraArgs: []

            # If false then the user will opt out of automounting API credentials.
            automountServiceAccountToken: true

            service:
              port: 8080
              # Default to clusterIP for backward compatibility
              type: ClusterIP
              ipDualStack:
                enabled: false
                ipFamilies: ["IPv6", "IPv4"]
                ipFamilyPolicy: "PreferDualStack"
              nodePort: 0
              loadBalancerIP: ""
              # Only allow access to the loadBalancerIP from these IPs
              loadBalancerSourceRanges: []
              clusterIP: ""
              annotations: {}

            ## Additional labels to add to all resources
            customLabels: {}
              # app: kube-state-metrics

            ## Override selector labels
            selectorOverride: {}

            ## set to true to add the release label so scraping of the servicemonitor with kube-prometheus-stack works out of the box
            releaseLabel: false

            hostNetwork: false

            rbac:
              # If true, create & use RBAC resources
              create: true

              # Set to a rolename to use existing role - skipping role creating - but still doing serviceaccount and rolebinding to it, rolename set here.
              # useExistingRole: your-existing-role

              # If set to false - Run without Cluteradmin privs needed - ONLY works if namespace is also set (if useExistingRole is set this name is used as ClusterRole or Role to bind to)
              useClusterRole: true

              # Add permissions for CustomResources' apiGroups in Role/ClusterRole. Should be used in conjunction with Custom Resource State Metrics configuration
              # Example:
              # - apiGroups: ["monitoring.coreos.com"]
              #   resources: ["prometheuses"]
              #   verbs: ["list", "watch"]
              extraRules: []

            # Configure kube-rbac-proxy. When enabled, creates one kube-rbac-proxy container per exposed HTTP endpoint (metrics and telemetry if enabled).
            # The requests are served through the same service but requests are then HTTPS.
            kubeRBACProxy:
              enabled: false
              image:
                registry: quay.io
                repository: brancz/kube-rbac-proxy
                tag: v0.20.0
                sha: ""
                pullPolicy: IfNotPresent

              # This set --ignore-paths=/livez,/readyz to kubeRBACProxy container args
              # to allow the pod probes working properly with kubeRBACProxy enabled.
              ignoreProbePaths: true

              # List of additional cli arguments to configure kube-rbac-prxy
              # for example: --tls-cipher-suites, --log-file, etc.
              # all the possible args can be found here: https://github.com/brancz/kube-rbac-proxy#usage
              extraArgs: []

              ## Specify security settings for a Container
              ## Allows overrides and additional options compared to (Pod) securityContext
              ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
              containerSecurityContext:
                readOnlyRootFilesystem: true
                allowPrivilegeEscalation: false
                capabilities:
                  drop:
                  - ALL

              # Configure specific proxy endpoints port
              # This port is for healthz on readinessProbe
              proxyEndpointsPort: 8888

              resources: {}
                # We usually recommend not to specify default resources and to leave this as a conscious
                # choice for the user. This also increases chances charts run on environments with little
                # resources, such as Minikube. If you do want to specify resources, uncomment the following
                # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
                # limits:
                #  cpu: 100m
                #  memory: 64Mi
                # requests:
                #  cpu: 10m
                #  memory: 32Mi

              ## volumeMounts enables mounting custom volumes in rbac-proxy containers
              ## Useful for TLS certificates and keys
              volumeMounts: []
                # - mountPath: /etc/tls
                #   name: kube-rbac-proxy-tls
                #   readOnly: true

            serviceAccount:
              # Specifies whether a ServiceAccount should be created, require rbac true
              create: true
              # The name of the ServiceAccount to use.
              # If not set and create is true, a name is generated using the fullname template
              name:
              # Reference to one or more secrets to be used when pulling images
              # ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
              imagePullSecrets: []
              # ServiceAccount annotations.
              # Use case: AWS EKS IAM roles for service accounts
              # ref: https://docs.aws.amazon.com/eks/latest/userguide/specify-service-account-role.html
              annotations: {}
              # If false then the user will opt out of automounting API credentials.
              automountServiceAccountToken: true

            # Additional Environment variables
            env: []
              # - name: GOMAXPROCS
              #   valueFrom:
              #     resourceFieldRef:
              #       resource: limits.cpu

            prometheus:
              monitor:
                enabled: true
                annotations: {}
                additionalLabels: {}
                namespace: ""
                namespaceSelector: []
                jobLabel: ""
                targetLabels: []
                podTargetLabels: []
                ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
                ##
                sampleLimit: 0

                ## TargetLimit defines a limit on the number of scraped targets that will be accepted.
                ##
                targetLimit: 0

                ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
                ##
                labelLimit: 0

                ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
                ##
                labelNameLengthLimit: 0

                ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
                ##
                labelValueLengthLimit: 0
                selectorOverride: {}

