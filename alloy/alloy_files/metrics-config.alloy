logging {
    level  = "info"
    format = "json"
}

livedebugging {
        enabled = true
}

discovery.kubernetes "pods" {
        role = "pod"
}

prometheus.scrape "pods" {
        scrape_interval = "10s"
        targets         = discovery.kubernetes.pods.targets
        forward_to      = [prometheus.remote_write.default.receiver]
}


discovery.kubernetes "services" {
        role = "service"
}

prometheus.scrape "services" {
        scrape_interval = "10s"
        targets         = discovery.kubernetes.services.targets
        forward_to      = [prometheus.remote_write.default.receiver]
}

discovery.kubernetes "endpoints" {
        role = "endpoints"
}

prometheus.scrape "endpoints" {
        scrape_interval = "10s"
        targets         = discovery.kubernetes.endpoints.targets
        forward_to      = [prometheus.remote_write.default.receiver]
}

discovery.kubernetes "endpointslices" {
        role = "endpointslice"
}

prometheus.scrape "endpointslices" {
        scrape_interval = "10s"
        targets         = discovery.kubernetes.endpointslices.targets
        forward_to      = [prometheus.remote_write.default.receiver]
}

discovery.kubernetes "ingresses" {
        role = "ingress"
}

prometheus.scrape "ingresses" {
        scrape_interval = "10s"
        targets         = discovery.kubernetes.ingresses.targets
        forward_to      = [prometheus.remote_write.default.receiver]
}

discovery.kubernetes "nodes" {
        role = "node"
}

prometheus.scrape "nodes" {
        scrape_interval = "10s"
        targets         = discovery.kubernetes.nodes.targets
        forward_to      = [prometheus.remote_write.default.receiver]
}

discovery.relabel "kubelet" {
        targets = discovery.kubernetes.nodes.targets

        rule {
            replacement  = "kubernetes.default.svc:443"
            target_label = "__address__"
        }

        rule {
            regex	      = "(.+)"
            source_labels = ["__meta_kubernetes_node_name"]
            replacement   = "/api/v1/nodes/$1/proxy/metrics"
            target_label  = "__metrics_path__"
        }

        rule {
            source_labels = ["__meta_kubernetes_node_address_hostname"]
            target_label  = "node"
        }
}

prometheus.operator.servicemonitors "default" {
        forward_to = [prometheus.remote_write.default.receiver]
        scrape {
            default_scrape_interval = "10s"
            default_scrape_timeout  = "5s"
        }
}

prometheus.operator.podmonitors "default" {
        forward_to = [prometheus.remote_write.default.receiver]
        scrape {
            default_scrape_interval = "10s"
            default_scrape_timeout  = "5s"
        }
}

prometheus.remote_write "default" {
        endpoint {
            url = "http://mimir-nginx.monitoring.svc:80/api/v1/push"
        }
}

tracing {
  sampling_fraction = 0.1

  write_to = [otelcol.exporter.otlp.tempo1.input, otelcol.exporter.otlp.tempo2.input]
}

otelcol.receiver.otlp "otlp_receiver" {
  // Listen on all available bindable addresses on port 4317 (which is the
  // default OTLP gRPC port) for the OTLP protocol.
  grpc {
    endpoint = "0.0.0.0:4317"
  }

  http {
    endpoint = "0.0.0.0:4318"

    cors {
      allowed_origins = ["*"]
      allowed_headers = ["*"]
      max_age         = 600
    }
  }

  output {
    traces = [otelcol.exporter.otlp.tempo1.input, otelcol.exporter.otlp.tempo2.input,]
  }
}

// OTLP exporter to Tempo
otelcol.exporter.otlp "tempo1" {
  client {
    endpoint = "tempo-distributor.monitoring.svc:4318"
    tls {
      insecure = true
    }
  }
}

otelcol.exporter.otlp "tempo2" {
    // Define the client for exporting.
    client {
        // Send to the locally running Tempo instance
        endpoint = "tempo-distributor.monitoring.svc:4318"
        // Disable TLS for OTLP remote write.
        tls {
            // The connection is insecure.
            insecure = true
            // Do not verify TLS certificates when connecting.
            insecure_skip_verify = true
        }
    }
}
