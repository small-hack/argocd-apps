logging {
    level  = "info"
    format = "json"
}

livedebugging {
        enabled = false
}

discovery.kubernetes "nodes" {
        role = "node"
}

prometheus.scrape "nodes" {
        scrape_interval = "15s"
        targets         = discovery.kubernetes.nodes.targets
        forward_to      = [prometheus.remote_write.default.receiver]
	clustering {
	    enabled = true
	}
}

prometheus.operator.servicemonitors "default" {
        forward_to = [prometheus.remote_write.default.receiver]
        scrape {
            default_scrape_interval = "15s"
            default_scrape_timeout  = "5s"
        }
	clustering {
	    enabled = true
	}
}

prometheus.operator.podmonitors "default" {
        forward_to = [prometheus.remote_write.default.receiver]
        scrape {
            default_scrape_interval = "15s"
            default_scrape_timeout  = "5s"
        }
	clustering {
	    enabled = true
	}
}

prometheus.scrape "kubelet" {
	job_name     = "integrations/kubernetes/kubelet"
	targets	     = discovery.kubernetes.nodes.targets
	scheme	     = "https"
	honor_labels = true

	tls_config {
	    server_name		 = "kubernetes"
	    ca_file		 = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	    insecure_skip_verify = false
	}

	clustering {
	    enabled = true
	}

	bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
	forward_to	  = [prometheus.relabel.kubelet.receiver]
}

prometheus.scrape "cadvisor" {
	job_name   = "kubelet"
 	targets    = discovery.kubernetes.nodes.targets
 	scheme     = "https"
 	scrape_interval = "15s"
	honor_labels = true
	metrics_path = "/metrics/cadvisor"


	tls_config {
	  ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	  insecure_skip_verify = false
	}

	clustering {
	    enabled = true
	}

 	bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
	forward_to = [prometheus.relabel.cadvisor.receiver]
}

// the "metrics_path" label is required for the "kubelet" jobs to
// be compatible with the kube-prometheus-stack alerting rules
prometheus.relabel "kubelet" {
	rule {
	    replacement = "/metrics"
	    target_label = "metrics_path"
	}

	rule {
	    source_labels = ["__meta_kubernetes_node_address_Hostname"]
	    target_label  = "node"
	}

	forward_to = [prometheus.remote_write.default.receiver]
}

prometheus.relabel "cadvisor" {
	rule {
	    replacement = "/metrics/cadvisor"
	    target_label = "metrics_path"
	}

	rule {
	    source_labels = ["__meta_kubernetes_node_address_Hostname"]
	    target_label  = "node"
	}

	forward_to = [prometheus.remote_write.default.receiver]
}

prometheus.remote_write "default" {
        endpoint {
            url = "http://mimir-nginx.monitoring.svc:80/api/v1/push"
        }

	external_labels = {
	    "cluster" = "default",
	}

	wal {
	    truncate_frequency = "15m"
	    min_keepalive_time = "5m"
	    max_keepalive_time = "30m"
	}
}

import.git "ksm" {
  repository = "https://github.com/grafana/alloy-modules.git"
  revision = "main"
  path = "modules/kubernetes/kube-state-metrics/metrics.alloy"
  pull_frequency = "15m"
}

ksm.kubernetes "targets" {}

ksm.scrape "metrics" {
  targets = ksm.kubernetes.targets.output
  
  forward_to = [
    prometheus.remote_write.default.receiver,
  ]
}
