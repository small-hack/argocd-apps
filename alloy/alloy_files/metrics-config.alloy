logging {
    level  = "info"
    format = "json"
}

livedebugging {
        enabled = false
}

discovery.kubernetes "nodes" {
        role = "node"
}

prometheus.scrape "nodes" {
        scrape_interval = "30s"
        targets         = discovery.kubernetes.nodes.targets
        forward_to      = [prometheus.remote_write.default.receiver]
	clustering {
	    enabled = true
	}
}

discovery.relabel "kubelet" {
        targets = discovery.kubernetes.nodes.targets

        rule {
            replacement  = "kubernetes.default.svc:443"
            target_label = "__address__"
        }

        rule {
            regex	      = "(.+)"
            source_labels = ["__meta_kubernetes_node_name"]
            replacement   = "/api/v1/nodes/$1/proxy/metrics"
            target_label  = "__metrics_path__"
        }

        rule {
            source_labels = ["__meta_kubernetes_node_address_hostname"]
            target_label  = "node"
        }
}

prometheus.scrape "kubelet" {
	job_name = "integrations/kubernetes/kubelet"
	targets  = discovery.relabel.kubelet.output
	scheme   = "https"

	tls_config {
	    server_name		 = "kubernetes"
	    ca_file		 = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
	    insecure_skip_verify = false
	}

	bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
	forward_to	  = [prometheus.remote_write.default.receiver]
}

prometheus.operator.servicemonitors "default" {
        forward_to = [prometheus.remote_write.default.receiver]
        scrape {
            default_scrape_interval = "30s"
            default_scrape_timeout  = "5s"
        }
	clustering {
	    enabled = true
	}
}

prometheus.operator.podmonitors "default" {
        forward_to = [prometheus.remote_write.default.receiver]
        scrape {
            default_scrape_interval = "30s"
            default_scrape_timeout  = "5s"
        }
	clustering {
	    enabled = true
	}
}

//discovery.relabel "cadvisor" {
//	targets = discovery.kubernetes.nodes.targets
//
//	rule {
//	    replacement     = "/metrics/cadvisor"
//	    target_label    = "__metrics_path__"
//	}
//
//	rule {
//	    replacement	  = "kubernetes.default.svc:443"
//	    target_label  = "__address__"
//	}
//
//	rule {
//	    regex         = "(.+)"
//	    source_labels = ["__meta_kubernetes_node_name"]
//	    replacement   = "/api/v1/nodes/$1/proxy/metrics/cadvisor"
//	    target_label  = "__metrics_path__"
//	}
//
//	rule {
//	    source_labels = ["__meta_kubernetes_node_address_Hostname"]
//	    target_label  = "node"
//	}
//}

//prometheus.scrape "cadvisor" {
//	job_name   = "integrations/kubernetes/cadvisor"
// 	targets    = discovery.relabel.cadvisor.output
// 	scheme     = "https"
// 	scrape_interval = "30s"
// 	bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
//
//	tls_config {
// 	  insecure_skip_verify = true
// 	}
//
//	clustering {
//	    enabled = true
//	}
//
//	forward_to = [prometheus.remote_write.default.receiver]
//}

prometheus.remote_write "default" {
        endpoint {
            url = "http://mimir-nginx.monitoring.svc:80/api/v1/push"
        }

	external_labels = {
	    "cluster" = "default",
	}
}

tracing {
  sampling_fraction = 0.1

  write_to = [otelcol.exporter.otlp.tempo.input]
}

otelcol.receiver.otlp "otlp_receiver" {
  // Listen on all available bindable addresses on port 4317 (which is the
  // default OTLP gRPC port) for the OTLP protocol.
  grpc {
    endpoint = "0.0.0.0:4317"
  }

  http {
    endpoint = "0.0.0.0:4318"

    cors {
      allowed_origins = ["*"]
      allowed_headers = ["*"]
      max_age         = 600
    }
  }

  output {
    traces = [otelcol.exporter.otlp.tempo.input]
  }
}

// OTLP exporter to Tempo
otelcol.exporter.otlp "tempo" {
  client {
    endpoint = "tempo-gateway.monitoring.svc:4317"
    tls {
      insecure = true
      insecure_skip_verify = true
    }
  }
}

import.git "ksm" {
  repository = "https://github.com/grafana/alloy-modules.git"
  revision = "main"
  path = "modules/kubernetes/kube-state-metrics/metrics.alloy"
  pull_frequency = "15m"
}

ksm.kubernetes "targets" {}

ksm.scrape "metrics" {
  targets = ksm.kubernetes.targets.output
  forward_to = [
    prometheus.remote_write.default.receiver,
  ]
}


