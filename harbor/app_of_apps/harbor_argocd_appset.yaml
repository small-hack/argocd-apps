apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: harbor-app-set
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "4"
spec:
  goTemplate: true
  generators:
    - plugin:
        configMapRef:
          name: secret-var-plugin-generator
        input:
          parameters:
            secret_vars:
              - global_cluster_issuer
              - global_time_zone
              - global_storage_class
              - harbor_hostname
              - harbor_s3_endpoint
              - vouch_hostname

  template:
    # meta data of the Argo CD Application generated by the above ApplicationSet
    metadata:
      name: harbor-web-app
      annotations:
        argocd.argoproj.io/sync-wave: "4"
        argocd.argoproj.io/sync-options: ApplyOnly=true

    spec:
      project: harbor

      # how to reconcile differences should this application get out of date
      syncPolicy:
        syncOptions:
          - ApplyOutOfSyncOnly=true
        automated:
          prune: true
          selfHeal: true

      # where to deploy this to
      destination:
        server: https://kubernetes.default.svc
        namespace: harbor

      # where to get the source of this application
      source:
        repoURL: 'https://helm.goharbor.io'
        chart: harbor
        targetRevision: 1.17.2
        helm:
          releaseName: harbor
          valuesObject:
            fullnameOverride: "harbor"
            expose:
              type: ingress
              tls:
                enabled: true
                # The source of the tls certificate. Set as "auto", "secret"
                # or "none" and fill the information in the corresponding section
                # 1) auto: generate the tls certificate automatically
                # 2) secret: read the tls certificate from the specified secret.
                # The tls certificate can be generated manually or by cert manager
                # 3) none: configure no tls certificate for the ingress. If the default
                # tls certificate is configured in the ingress controller, choose this option
                certSource: none
                auto:
                  # The common name used to generate the certificate, it's necessary
                  # when the type isn't "ingress"
                  commonName: ""
                secret:
                  # The name of secret which contains keys named:
                  # "tls.crt" - the certificate
                  # "tls.key" - the private key
                  secretName: ""
              ingress:
                hosts:
                  core: "{{ .harbor_hostname }}"
                # set to the type of ingress controller if it has specific requirements.
                # leave as `default` for most ingress controllers.
                # set to `gce` if using the GCE ingress controller
                # set to `ncp` if using the NCP (NSX-T Container Plugin) ingress controller
                # set to `alb` if using the ALB ingress controller
                # set to `f5-bigip` if using the F5 BIG-IP ingress controller
                controller: default
                ## Allow .Capabilities.KubeVersion.Version to be overridden while creating ingress
                kubeVersionOverride: ""
                className: "nginx"
                annotations:
                  cert-manager.io/cluster-issuer: "{{ .global_cluster_issuer }}"
                  ngress.kubernetes.io/ssl-redirect: "true"
                  ingress.kubernetes.io/proxy-body-size: "0"
                  nginx.ingress.kubernetes.io/ssl-redirect: "true"
                  nginx.ingress.kubernetes.io/proxy-body-size: "0"
              clusterIP:
                # The name of ClusterIP service
                name: harbor
                # The ip address of the ClusterIP service (leave empty for acquiring dynamic ip)
                staticClusterIP: ""
                ports:
                  # The service port Harbor listens on when serving HTTP
                  httpPort: 80
                  # The service port Harbor listens on when serving HTTPS
                  httpsPort: 443
                # Annotations on the ClusterIP service
                annotations: {}
                # ClusterIP-specific labels
                labels: {}
              nodePort:
                # The name of NodePort service
                name: harbor
                ports:
                  http:
                    # The service port Harbor listens on when serving HTTP
                    port: 80
                    # The node port Harbor listens on when serving HTTP
                    nodePort: 30002
                  https:
                    # The service port Harbor listens on when serving HTTPS
                    port: 443
                    # The node port Harbor listens on when serving HTTPS
                    nodePort: 30003
                # Annotations on the nodePort service
                annotations: {}
                # nodePort-specific labels
                labels: {}
              loadBalancer:
                # The name of LoadBalancer service
                name: harbor
                # Set the IP if the LoadBalancer supports assigning IP
                IP: ""
                ports:
                  # The service port Harbor listens on when serving HTTP
                  httpPort: 80
                  # The service port Harbor listens on when serving HTTPS
                  httpsPort: 443
                # Annotations on the loadBalancer service
                annotations: {}
                # loadBalancer-specific labels
                labels: {}
                sourceRanges: []

            externalURL: "https://{{ .harbor_hostname }}"

            # log level used for Harbor services. Allowed values: fatal, error, warn, info, debug, trace
            logLevel: debug

            ## TLS settings
            ## Note: TLS cert files need to provided in each components in advance.
            ##
            internalTLS:
              ## @param internalTLS.enabled Use TLS in all the supported containers: core, jobservice, portal, registry and trivy
              enabled: false
              ## @param internalTLS.caBundleSecret Name of an existing secret with a custom CA that will be injected into the trust store for core, jobservice, registry, trivy components
              ## The secret must contain the key "ca.crt"
              caBundleSecret: ""

            ## @param exposureType The way to expose Harbor. Allowed values are [ ingress \| proxy ]
            ## Use "proxy" to use a deploy NGINX proxy in front of Harbor services
            ## Use "ingress" to use an Ingress Controller as proxy
            ##
                        # The persistence is enabled by default and a default StorageClass
            # is needed in the k8s cluster to provision volumes dynamically.
            # Specify another StorageClass in the "storageClass" or set "existingClaim"
            # if you already have existing persistent volumes to use
            #
            # For storing images and charts, you can also use "azure", "gcs", "s3",
            # "swift" or "oss". Set it in the "imageChartStorage" section
            persistence:
              enabled: true
              resourcePolicy: "keep"
              persistentVolumeClaim:
                registry:
                  existingClaim: "registry"

                jobservice:
                  jobLog:
                    existingClaim: "jobs"

                trivy:
                  existingClaim: "trivy"
                  storageClass: "{{ .global_storage_class }}"

              # Define which storage backend is used for registry to store
              # images and charts. Refer to
              # https://github.com/distribution/distribution/blob/main/docs/configuration.md#storage
              # for the detail.
              imageChartStorage:
                # Specify whether to disable `redirect` for images and chart storage, for
                # backends which not supported it (such as using minio for `s3` storage type), please disable
                # it. To disable redirects, simply set `disableredirect` to `true` instead.
                # Refer to
                # https://github.com/distribution/distribution/blob/main/docs/configuration.md#redirect
                # for the detail.
                disableredirect: true
                # Specify the "caBundleSecretName" if the storage service uses a self-signed certificate.
                # The secret must contain keys named "ca.crt" which will be injected into the trust store
                # of registry's containers.
                # caBundleSecretName:

                # Specify the type of storage: "filesystem", "azure", "gcs", "s3", "swift",
                # "oss" and fill the information needed in the corresponding section. The type
                # must be "filesystem" if you want to use persistent volumes for registry
                type: s3

                s3:
                  # keys in the secret should be REGISTRY_STORAGE_S3_ACCESSKEY and REGISTRY_STORAGE_S3_SECRETKEY for registry
                  existingSecret: "admin-s3-credentials"
                  region: us-west-1
                  bucket: harbor

            # The initial password of Harbor admin. Change it from portal after launching Harbor
            # or give an existing secret for it
            # key in secret is given via (default to HARBOR_ADMIN_PASSWORD)
            existingSecretAdminPassword: "harbor-admin-credentials"
            existingSecretAdminPasswordKey: password

            # The name of the secret which contains key named "ca.crt". Setting this enables the
            # download link on portal to download the CA certificate when the certificate isn't
            # generated automatically
            caSecretName: ""
            # If using existingSecretSecretKey, the key must be secretKey
            existingSecretSecretKey: "harbor-admin-credentials"

            # Run the migration job via helm hook
            enableMigrateHelmHook: false
            # The custom ca bundle secret, the secret must contain key named "ca.crt"
            # which will be injected into the trust store for core, jobservice, registry, trivy components
            # caBundleSecretName: ""

            ## UAA Authentication Options
            # If you're using UAA for authentication behind a self-signed
            # certificate you will need to provide the CA Cert.
            # Set uaaSecretName below to provide a pre-created secret that
            # contains a base64 encoded CA Certificate named `ca.crt`.
            # uaaSecretName:

            portal:
              image:
                repository: goharbor/harbor-portal
                tag: dev
              # set the service account to be used, default if left empty
              serviceAccountName: ""
              # mount the service account token
              automountServiceAccountToken: false
              replicas: 1
              revisionHistoryLimit: 10
              # resources:
              #  requests:
              #    memory: 256Mi
              #    cpu: 100m
              extraEnvVars: []
              nodeSelector: {}
              tolerations: []
              affinity: {}
              # Spread Pods across failure-domains like regions, availability zones or nodes
              topologySpreadConstraints: []
              # - maxSkew: 1
              #   topologyKey: topology.kubernetes.io/zone
              #   nodeTaintsPolicy: Honor
              #   whenUnsatisfiable: DoNotSchedule
              ## Additional deployment annotations
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
              ## The priority class to run the pod as
              priorityClassName:

            core:
              ## Existing secret for core
              ## The secret must contain the keys:
              ## `secret` (required),
              ## `secretKey` (required),
              existingSecret: "harbor-admin-credentials"
              ## Existing secret for core envvars
              ## The secret must contain the keys:
              ## `CSRF_KEY` (optional - alternatively auto-generated),
              ## `HARBOR_ADMIN_PASSWORD` (optional - alternatively auto-generated),
              ## `POSTGRESQL_PASSWORD` (optional - alternatively uses weak upstream default. Read below if you set it. You must also set postgresql.auth.existingSecret to the same value as core.existingEnvVarsSecret for this to work!),
              ## `postgres-password` (required if POSTGRESQL_PASSWORD is set & must be the same as POSTGRESQL_PASSWORD.)
              ## `HARBOR_DATABASE_PASSWORD` (required if POSTGRESQL_PASSWORD is set & must be the same as POSTGRESQL_PASSWORD.)
              ## `REGISTRY_CREDENTIAL_USERNAME` (optional - alternatively weak defaults),
              ## `REGISTRY_CREDENTIAL_PASSWORD` (optional - alternatively weak defaults),
              ## `_REDIS_URL_CORE` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/0")
              ## `_REDIS_URL_REG` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/2")
              ##
              ## If you do not know how to start, let the chart generate a full secret for you before defining an existingEnvVarsSecret
              ## Notes:
              ##   As a EnvVars secret, this secret also store redis config urls
              ##   The HARBOR_ADMIN_PASSWORD is only required at initial deployment, once the password is set in database, it is not used anymore
              existingEnvVarsSecret: "harbor-registry-credentials"
              extraEnvVars:
              - name: OIDC_CLIENT_ID
                valueFrom:
                  secretKeyRef:
                    name: oidc-harbor
                    key: client_id
              - name: OIDC_CLIENT_SECRET
                valueFrom:
                  secretKeyRef:
                    name: oidc-harbor
                    key: client_secret
              - name: OIDC_ENDPOINT
                valueFrom:
                  secretKeyRef:
                    name: oidc-harbor
                    key: endpoint
              - name: CONFIG_OVERWRITE_JSON
                value: |
                  {
                    "auth_mode": "oidc_auth",
                    "oidc_name": "Zitadel",
                    "oidc_endpoint": "$(OIDC_ENDPOINT)",
                    "oidc_groups_claim": "groups",
                    "oidc_admin_group": "harbor_admins",
                    "oidc_client_id": "$(OIDC_CLIENT_ID)",
                    "oidc_client_secret": "$(OIDC_CLIENT_SECRET)",
                    "oidc_scope": "openid,email,groups,name",
                    "oidc_verify_cert": "false",
                    "oidc_auto_onboard": "true",
                    "oidc_user_claim": "name"
                  }

            jobservice:
              # Secret is used when job service communicates with other components.
              # If a secret key is not specified, Helm will generate one.
              # Must be a string of 16 chars.
              secret: ""
              ## @param jobservice.existingSecret Existing secret for jobservice
              ## The secret must contain the keys:
              ## `secret` (required),
              ##
              existingSecret: "harbor-admin-credentials"

            registry:
              credentials:
                username: "harbor_registry_user"
                password: "harbor_registry_password"
                # Login and password in htpasswd string format. Excludes `registry.credentials.username`  and `registry.credentials.password`. May come in handy when integrating with tools like argocd or flux. This allows the same line to be generated each time the template is rendered, instead of the `htpasswd` function from helm, which generates different lines each time because of the salt.
                # htpasswd: $apr1$XLefHzeG$Xl4.s00sMSCCcMyJljSZb0 # example string
                # If using existingSecret, the key must be REGISTRY_PASSWD and REGISTRY_HTPASSWD
                existingSecret: ""

            trivy:
              # enabled the flag to enable Trivy scanner
              enabled: true
              ## @param trivy.existingEnvVarsSecret Existing secret for trivy
              ## The secret must contain the keys:
              ## `SCANNER_TRIVY_GITHUB_TOKEN` (optional)
              ## `SCANNER_REDIS_URL` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/5")
              ## `SCANNER_STORE_REDIS_URL` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/5")
              ## `SCANNER_JOB_QUEUE_REDIS_URL` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/5")
              ##
              existingEnvVarsSecret: ""

            externalDatabase:
              host: "harbor-postgrees-rw"
              port: "5432"
              user: "harbor"
              coreDatabase: "registry"
              # if using existing secret, the key must be "password"
              existingSecret: "harbor-pgsql-credentials"
              existingSecretPasswordKey: "password"
              # "disable" - No SSL
              # "require" - Always SSL (skip verification)
              # "verify-ca" - Always SSL (verify that the certificate presented by the
              # server was signed by a trusted CA)
              # "verify-full" - Always SSL (verify that the certification presented by the
              # server was signed by a trusted CA and the server host name matches the one
              # in the certificate)
              sslmode: "disable"

            externalRedis:
              host: "valkey-primary"
              port: 6379
              password: ""
              # If using existingSecret, the key must be REDIS_PASSWORD
              existingSecret: "harbor-valkey-credentials"
              coreDatabaseIndex: "0"
              jobserviceDatabaseIndex: "1"
              registryDatabaseIndex: "2"
              trivyAdapterDatabaseIndex: "5"
              ## Redis&reg; sentinel configuration
              sentinel:
                ## If external redis with sentinal is used, set it to `true`
                enabled: false
                ## Name of sentinel masterSet if sentinel is used
                masterSet: "mymaster"
                ## Sentinel hosts and ports in the format
                hosts: ""

            exporter:
              replicaCount: 1
              revisionHistoryLimit: 2
              # resources:
              #  requests:
              #    memory: 256Mi
              #    cpu: 100m

            metrics:
              enabled: true
              core:
                path: /metrics
                port: 8001
              registry:
                path: /metrics
                port: 8001
              jobservice:
                path: /metrics
                port: 8001
              exporter:
                path: /metrics
                port: 8001
              ## Create prometheus serviceMonitor to scrape harbor metrics.
              ## This requires the monitoring.coreos.com/v1 CRD. Please see
              ## https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/user-guides/getting-started.md
              ##
              serviceMonitor:
                enabled: true

            # cache layer configurations
            # if this feature enabled, harbor will cache the resource
            # `project/project_metadata/repository/artifact/manifest` in the redis
            # which help to improve the performance of high concurrent pulling manifest.
            cache:
              # default is not enabled.
              enabled: true
              # default keep cache for one day.
              expireHours: 24
