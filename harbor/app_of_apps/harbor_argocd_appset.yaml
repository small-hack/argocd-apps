apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: harbor-app-set
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-wave: "4"
spec:
  goTemplate: true
  generators:
    - plugin:
        configMapRef:
          name: secret-var-plugin-generator
        input:
          parameters:
            secret_vars:
              - global_cluster_issuer
              - global_time_zone
              - global_storage_class
              - harbor_hostname
              - harbor_s3_endpoint
              - vouch_hostname

  template:
    # meta data of the Argo CD Application generated by the above ApplicationSet
    metadata:
      name: harbor-web-app
      annotations:
        argocd.argoproj.io/sync-wave: "4"
        argocd.argoproj.io/sync-options: ApplyOnly=true

    spec:
      project: harbor

      # how to reconcile differences should this application get out of date
      syncPolicy:
        syncOptions:
          - ApplyOutOfSyncOnly=true
        automated:
          prune: true
          selfHeal: true

      # where to deploy this to
      destination:
        server: https://kubernetes.default.svc
        namespace: harbor

      # where to get the source of this application
      source:
        repoURL: 'https://helm.goharbor.io'
        chart: harbor
        targetRevision: 1.18.0
        helm:
          releaseName: harbor
          valuesObject:
            fullnameOverride: "harbor"
            # The initial password of Harbor admin. Change it from portal after launching Harbor
            # or give an existing secret for it
            # key in secret is given via (default to HARBOR_ADMIN_PASSWORD)
            existingSecretAdminPassword: "harbor-registry-credentials"
            #existingSecretAdminPasswordKey: password
            # The name of the secret which contains key named "ca.crt". Setting this enables the
            # download link on portal to download the CA certificate when the certificate isn't
            # generated automatically
            caSecretName: ""
            # If using existingSecretSecretKey, the key must be secretKey
            #existingSecretSecretKey: "harbor-admin-credentials"
            # Run the migration job via helm hook
            enableMigrateHelmHook: false
            # The custom ca bundle secret, the secret must contain key named "ca.crt"
            # which will be injected into the trust store for core, jobservice, registry, trivy components
            # caBundleSecretName: ""
            externalURL: "https://{{ .harbor_hostname }}"
            # log level used for Harbor services. Allowed values: fatal, error, warn, info, debug, trace
            logLevel: debug
            # The update strategy for deployments with persistent volumes(jobservice, registry): "RollingUpdate" or "Recreate"
            # Set it as "Recreate" when "RWM" for volumes isn't supported
            updateStrategy:
              type: RollingUpdate
            ################################################################################
            #  _____
            # | ____|_  ___ __   ___  ___  ___
            # |  _| \ \/ / '_ \ / _ \/ __|/ _ \
            # | |___ >  <| |_) | (_) \__ \  __/
            # |_____/_/\_\ .__/ \___/|___/\___|
            #            |_|
            ################################################################################
            ## @param exposureType The way to expose Harbor. Allowed values are [ ingress \| proxy ]
            ## Use "proxy" to use a deploy NGINX proxy in front of Harbor services
            ## Use "ingress" to use an Ingress Controller as proxy
            expose:
              # Set how to expose the service. Set the type as "ingress", "clusterIP", "nodePort" or "loadBalancer"
              # and fill the information in the corresponding section
              type: ingress
              tls:
                # Enable TLS or not.
                # Delete the "ssl-redirect" annotations in "expose.ingress.annotations" when TLS is disabled and "expose.type" is "ingress"
                # Note: if the "expose.type" is "ingress" and TLS is disabled,
                # the port must be included in the command when pulling/pushing images.
                # Refer to https://github.com/goharbor/harbor/issues/5291 for details.
                enabled: true
                # The source of the tls certificate. Set as "auto", "secret"
                # or "none" and fill the information in the corresponding section
                # 1) auto: generate the tls certificate automatically
                # 2) secret: read the tls certificate from the specified secret.
                # The tls certificate can be generated manually or by cert manager
                # 3) none: configure no tls certificate for the ingress. If the default
                # tls certificate is configured in the ingress controller, choose this option
                certSource: secret
                auto:
                  # The common name used to generate the certificate, it's necessary
                  # when the type isn't "ingress"
                  commonName: ""
                secret:
                  # The name of secret which contains keys named:
                  # "tls.crt" - the certificate
                  # "tls.key" - the private key
                  secretName: "harbor-tls"
              ingress:
                hosts:
                  core: "{{ .harbor_hostname }}"
                # set to the type of ingress controller if it has specific requirements.
                # leave as `default` for most ingress controllers.
                # set to `gce` if using the GCE ingress controller
                # set to `ncp` if using the NCP (NSX-T Container Plugin) ingress controller
                # set to `alb` if using the ALB ingress controller
                # set to `f5-bigip` if using the F5 BIG-IP ingress controller
                controller: default
                ## Allow .Capabilities.KubeVersion.Version to be overridden while creating ingress
                kubeVersionOverride: ""
                className: "nginx"
                annotations:
                  # note different ingress controllers may require a different ssl-redirect annotation
                  # for Envoy, use ingress.kubernetes.io/force-ssl-redirect: "true" and remove the nginx lines below
                  cert-manager.io/cluster-issuer: "{{ .global_cluster_issuer }}"
                  ingress.kubernetes.io/ssl-redirect: "true"
                  ingress.kubernetes.io/proxy-body-size: "0"
                  nginx.ingress.kubernetes.io/ssl-redirect: "true"
                  nginx.ingress.kubernetes.io/proxy-body-size: "0"
                # ingress-specific labels
                labels: {}
              route:
                labels: {}
                annotations: {}
                # - name: envoy-internal
                #   namespace: networking
                #   sectionName: https
                #   group: gateway.networking.k8s.io
                #   kind: Gateway
                parentRefs: {}
                # - "harbor.example.com"
                hosts: []
              clusterIP:
                # The name of ClusterIP service
                name: harbor
                # The ip address of the ClusterIP service (leave empty for acquiring dynamic ip)
                staticClusterIP: ""
                ports:
                  # The service port Harbor listens on when serving HTTP
                  httpPort: 80
                  # The service port Harbor listens on when serving HTTPS
                  httpsPort: 443
                # Annotations on the ClusterIP service
                annotations: {}
                # ClusterIP-specific labels
                labels: {}
              nodePort:
                # The name of NodePort service
                name: harbor
                ports:
                  http:
                    # The service port Harbor listens on when serving HTTP
                    port: 80
                    # The node port Harbor listens on when serving HTTP
                    nodePort: 30002
                  https:
                    # The service port Harbor listens on when serving HTTPS
                    port: 443
                    # The node port Harbor listens on when serving HTTPS
                    nodePort: 30003
                # Annotations on the nodePort service
                annotations: {}
                # nodePort-specific labels
                labels: {}
              loadBalancer:
                # The name of LoadBalancer service
                name: harbor
                # Set the IP if the LoadBalancer supports assigning IP
                IP: ""
                ports:
                  # The service port Harbor listens on when serving HTTP
                  httpPort: 80
                  # The service port Harbor listens on when serving HTTPS
                  httpsPort: 443
                # Annotations on the loadBalancer service
                annotations: {}
                # loadBalancer-specific labels
                labels: {}
                sourceRanges: []
            ################################################################################
            #  ___ ____   __                 _ _
            # |_ _|  _ \ / _| __ _ _ __ ___ (_) |_   _
            #  | || |_) | |_ / _` | '_ ` _ \| | | | | |
            #  | ||  __/|  _| (_| | | | | | | | | |_| |
            # |___|_|   |_|  \__,_|_| |_| |_|_|_|\__, |
            #                                    |___/
            ################################################################################
            ipFamily:
              # ipv6Enabled set to true if ipv6 is enabled in cluster, currently it affected the nginx related component
              ipv6:
                enabled: true
              # ipv4Enabled set to true if ipv4 is enabled in cluster, currently it affected the nginx related component
              ipv4:
                enabled: true
              # Sets the IP family policy for services to be able to configure dual-stack; see [Configure dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services).
              policy: ""
              # A list of IP families for services that should be supported, in the order in which they should be applied to ClusterIP. Can be "IPv4" and/or "IPv6".
              families: []
            ################################################################################
            #  ___       _                        _ _____ _     ____
            # |_ _|_ __ | |_ ___ _ __ _ __   __ _| |_   _| |   / ___|
            #  | || '_ \| __/ _ \ '__| '_ \ / _` | | | | | |   \___ \
            #  | || | | | ||  __/ |  | | | | (_| | | | | | |___ ___) |
            # |___|_| |_|\__\___|_|  |_| |_|\__,_|_| |_| |_____|____/
            ################################################################################
            internalTLS:
              ## @param internalTLS.enabled Use TLS in all the supported containers: core, jobservice, portal, registry and trivy
              enabled: false
              ## @param internalTLS.caBundleSecret Name of an existing secret with a custom CA that will be injected into the trust store for core, jobservice, registry, trivy components
              ## The secret must contain the key "ca.crt"
              caBundleSecret: ""
            ################################################################################
            #  ____
            # |  _ \ _ __ _____  ___   _
            # | |_) | '__/ _ \ \/ / | | |
            # |  __/| | | (_) >  <| |_| |
            # |_|   |_|  \___/_/\_\\__, |
            #                      |___/
            ################################################################################
            # The proxy settings for updating trivy vulnerabilities from the Internet and replicating
            # artifacts from/to the registries that cannot be reached directly
            proxy:
              httpProxy:
              httpsProxy:
              noProxy: 127.0.0.1,localhost,.local,.internal
              components:
                - core
                - jobservice
                - trivy
            ################################################################################
            #  ____               _     _
            # |  _ \ ___ _ __ ___(_)___| |_ ___ _ __   ___ ___
            # | |_) / _ \ '__/ __| / __| __/ _ \ '_ \ / __/ _ \
            # |  __/  __/ |  \__ \ \__ \ ||  __/ | | | (_|  __/
            # |_|   \___|_|  |___/_|___/\__\___|_| |_|\___\___|
            ################################################################################
            # The persistence is enabled by default and a default StorageClass
            # is needed in the k8s cluster to provision volumes dynamically.
            # Specify another StorageClass in the "storageClass" or set "existingClaim"
            # if you already have existing persistent volumes to use
            #
            # For storing images and charts, you can also use "azure", "gcs", "s3",
            # "swift" or "oss". Set it in the "imageChartStorage" section
            persistence:
              enabled: true
              # Setting it to "keep" to avoid removing PVCs during a helm delete
              # operation. Leaving it empty will delete PVCs after the chart deleted
              # (this does not apply for PVCs that are created for internal database
              # and redis components, i.e. they are never deleted automatically)
              resourcePolicy: "keep"
              persistentVolumeClaim:
                jobservice:
                  jobLog:
                    existingClaim: "jobs"
                trivy:
                  existingClaim: "trivy"
                  storageClass: "{{ .global_storage_class }}"
                # If external database is used, the following settings for database will
                # be ignored
                database:
                  existingClaim: ""
                  storageClass: ""
                  subPath: ""
                  accessMode: ReadWriteOnce
                  size: 1Gi
                  annotations: {}
                # If external Redis is used, the following settings for Redis will
                # be ignored
                redis:
                  existingClaim: ""
                  storageClass: ""
                  subPath: ""
                  accessMode: ReadWriteOnce
                  size: 1Gi
                  annotations: {}
              # Define which storage backend is used for registry to store
              # images and charts. Refer to
              # https://github.com/distribution/distribution/blob/main/docs/configuration.md#storage
              # for the detail.
              imageChartStorage:
                # Specify whether to disable `redirect` for images and chart storage, for
                # backends which not supported it (such as using minio for `s3` storage type), please disable
                # it. To disable redirects, simply set `disableredirect` to `true` instead.
                # Refer to
                # https://github.com/distribution/distribution/blob/main/docs/configuration.md#redirect
                # for the detail.
                disableredirect: true
                # Specify the "caBundleSecretName" if the storage service uses a self-signed certificate.
                # The secret must contain keys named "ca.crt" which will be injected into the trust store
                # of registry's containers.
                # caBundleSecretName:

                # Specify the type of storage: "filesystem", "azure", "gcs", "s3", "swift",
                # "oss" and fill the information needed in the corresponding section. The type
                # must be "filesystem" if you want to use persistent volumes for registry
                type: s3
                #filesystem:
                #  rootdirectory: /storage
                azure:
                  accountname: accountname
                  accountkey: base64encodedaccountkey
                  container: containername
                  # To use existing secret, the key must be AZURE_STORAGE_ACCESS_KEY
                  existingSecret: ""
                gcs:
                  bucket: bucketname
                  # The base64 encoded json file which contains the key
                  encodedkey: base64-encoded-json-key-file
                  # To use existing secret, the key must be GCS_KEY_DATA
                  existingSecret: ""
                  useWorkloadIdentity: false
                s3:
                  # keys in the secret should be REGISTRY_STORAGE_S3_ACCESSKEY and REGISTRY_STORAGE_S3_SECRETKEY for registry
                  existingSecret: "admin-s3-credentials"
                  region: us-east-1
                  regionendpoint: http://seaweedfs-s3.harbor.svc.cluster.local:8333
                  bucket: harbor
                swift:
                  authurl: https://storage.myprovider.com/v3/auth
                  username: username
                  password: password
                  container: containername
                  # keys in existing secret must be REGISTRY_STORAGE_SWIFT_PASSWORD, REGISTRY_STORAGE_SWIFT_SECRETKEY, REGISTRY_STORAGE_SWIFT_ACCESSKEY
                  existingSecret: ""
                oss:
                  accesskeyid: accesskeyid
                  accesskeysecret: accesskeysecret
                  region: regionname
                  bucket: bucketname
                  # key in existingSecret must be REGISTRY_STORAGE_OSS_ACCESSKEYSECRET
                  existingSecret: ""
            ################################################################################
            #  ____            _        _
            # |  _ \ ___  _ __| |_ __ _| |
            # | |_) / _ \| '__| __/ _` | |
            # |  __/ (_) | |  | || (_| | |
            # |_|   \___/|_|   \__\__,_|_|
            #
            ################################################################################
            portal:
              image:
                repository: goharbor/harbor-portal
                tag: dev
              # set the service account to be used, default if left empty
              serviceAccountName: ""
              # mount the service account token
              automountServiceAccountToken: false
              replicas: 1
              revisionHistoryLimit: 10
              # resources:
              #  requests:
              #    memory: 256Mi
              #    cpu: 100m
              extraEnvVars: []
              nodeSelector: {}
              tolerations: []
              affinity: {}
              # Spread Pods across failure-domains like regions, availability zones or nodes
              topologySpreadConstraints: []
              # - maxSkew: 1
              #   topologyKey: topology.kubernetes.io/zone
              #   nodeTaintsPolicy: Honor
              #   whenUnsatisfiable: DoNotSchedule
              ## Additional deployment annotations
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
              ## The priority class to run the pod as
              priorityClassName:
            ################################################################################
            #   ____
            #  / ___|___  _ __ ___
            # | |   / _ \| '__/ _ \
            # | |__| (_) | | |  __/
            #  \____\___/|_|  \___|
            ################################################################################
            core:
              image:
                repository: goharbor/harbor-core
                tag: dev
              # set the service account to be used, default if left empty
              serviceAccountName: ""
              # mount the service account token
              automountServiceAccountToken: false
              replicas: 1
              revisionHistoryLimit: 10
              ## Startup probe values
              startupProbe:
                enabled: true
                initialDelaySeconds: 10
              # resources:
              #  requests:
              #    memory: 256Mi
              #    cpu: 100m
              extraEnvVars:
               # - name: HARBOR_ADMIN_PASSWORD
               #   valueFrom:
               #     secretKeyRef:
               #       name: harbor-registry-credentials
               #       key: HARBOR_ADMIN_PASSWORD
               # - name: REGISTRY_CREDENTIAL_PASSWORD
               #   valueFrom:
               #     secretKeyRef:
               #       name: harbor-registry-credentials
               #       key: REGISTRY_CREDENTIAL_PASSWORD
               # - name: REGISTRY_CREDENTIAL_USERNAME
               #   valueFrom:
               #     secretKeyRef:
               #       name: harbor-registry-credentials
               #       key: REGISTRY_CREDENTIAL_USERNAME
               - name: OIDC_CLIENT_ID
                 valueFrom:
                   secretKeyRef:
                     name: oidc-harbor
                     key: client_id
               - name: OIDC_CLIENT_SECRET
                 valueFrom:
                   secretKeyRef:
                     name: oidc-harbor
                     key: client_secret
               - name: OIDC_ENDPOINT
                 valueFrom:
                   secretKeyRef:
                     name: oidc-harbor
                     key: endpoint
               - name: CONFIG_OVERWRITE_JSON
                 value: |
                   {
                     "auth_mode": "oidc_auth",
                     "oidc_name": "Zitadel",
                     "oidc_endpoint": "$(OIDC_ENDPOINT)",
                     "oidc_groups_claim": "groups",
                     "oidc_admin_group": "harbor_admins",
                     "oidc_client_id": "$(OIDC_CLIENT_ID)",
                     "oidc_client_secret": "$(OIDC_CLIENT_SECRET)",
                     "oidc_scope": "openid,email,profile"
                     "oidc_verify_cert": "false",
                     "oidc_auto_onboard": "true",
                     "oidc_user_claim": "preferred_username"
                   }
              nodeSelector: {}
              tolerations: []
              affinity: {}
              # Spread Pods across failure-domains like regions, availability zones or nodes
              topologySpreadConstraints: []
              ## Additional deployment annotations
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
              ## Additional service annotations
              serviceAnnotations: {}
              ## The priority class to run the pod as
              priorityClassName:
              # containers to be run before the controller's container starts.
              initContainers: []
              ## User settings configuration json string
              configureUserSettings:
              # The provider for updating project quota(usage), there are 2 options, redis or db.
              # By default it is implemented by db but you can configure it to redis which
              # can improve the performance of high concurrent pushing to the same project,
              # and reduce the database connections spike and occupies.
              # Using redis will bring up some delay for quota usage updation for display, so only
              # suggest switch provider to redis if you were ran into the db connections spike around
              # the scenario of high concurrent pushing to same project, no improvment for other scenes.
              quotaUpdateProvider: db # Or redis
              # Secret is used when core server communicates with other components.
              # If a secret key is not specified, Helm will generate one. Alternatively set existingSecret to use an existing secret
              # Must be a string of 16 chars.
              secret: ""
              # Fill in the name of a kubernetes secret if you want to use your own
              # If using existingSecret, the key must be secret
              #existingSecret: "harbor-admin-credentials"
              # Fill the name of a kubernetes secret if you want to use your own
              # TLS certificate and private key for token encryption/decryption.
              # The secret must contain keys named:
              # "tls.key" - the private key
              # "tls.crt" - the certificate
              secretName: ""
              # If not specifying a preexisting secret, a secret can be created from tokenKey and tokenCert and used instead.
              # If none of secretName, tokenKey, and tokenCert are specified, an ephemeral key and certificate will be autogenerated.
              # tokenKey and tokenCert must BOTH be set or BOTH unset.
              # The tokenKey value is formatted as a multiline string containing a PEM-encoded RSA key, indented one more than tokenKey on the following line.
              tokenKey: ""
              # If tokenKey is set, the value of tokenCert must be set as a PEM-encoded certificate signed by tokenKey, and supplied as a multiline string, indented one more than tokenCert on the following line.
              tokenCert: ""
              # The XSRF key. Will be generated automatically if it isn't specified
              # While you specified, Please make sure it is 32 characters, otherwise would have validation issue at the harbor-core runtime
              # https://github.com/goharbor/harbor/pull/21154
              xsrfKey: ""
              # If using existingSecret, the key is defined by core.existingXsrfSecretKey
              existingXsrfSecret: ""
              # If using existingSecret, the key
              existingXsrfSecretKey: CSRF_KEY
              # The time duration for async update artifact pull_time and repository
              # pull_count, the unit is second. Will be 10 seconds if it isn't set.
              # eg. artifactPullAsyncFlushDuration: 10
              artifactPullAsyncFlushDuration:
              gdpr:
                deleteUser: false
                auditLogsCompliant: false
            ################################################################################
            #      _       _                         _
            #     | | ___ | |__  ___  ___ _ ____   _(_) ___ ___
            #  _  | |/ _ \| '_ \/ __|/ _ \ '__\ \ / / |/ __/ _ \
            # | |_| | (_) | |_) \__ \  __/ |   \ V /| | (_|  __/
            #  \___/ \___/|_.__/|___/\___|_|    \_/ |_|\___\___|
            #
            ################################################################################
            jobservice:
              image:
                repository: goharbor/harbor-jobservice
                tag: dev
              # set the service account to be used, default if left empty
              serviceAccountName: ""
              # mount the service account token
              automountServiceAccountToken: false
              replicas: 1
              revisionHistoryLimit: 10
              # resources:
              #   requests:
              #     memory: 256Mi
              #     cpu: 100m
              extraEnvVars: []
              nodeSelector: {}
              tolerations: []
              affinity: {}
              # Spread Pods across failure-domains like regions, availability zones or nodes
              topologySpreadConstraints:
              ## Additional deployment annotations
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
              ## The priority class to run the pod as
              priorityClassName:
              # containers to be run before the controller's container starts.
              initContainers: []
              maxJobWorkers: 10
              # The logger for jobs: "file", "database" or "stdout"
              jobLoggers:
                - file
                # - database
                # - stdout
              # The jobLogger sweeper duration (ignored if `jobLogger` is `stdout`)
              loggerSweeperDuration: 14 #days
              notification:
                webhook_job_max_retry: 3
                webhook_job_http_client_timeout: 3 # in seconds
              reaper:
                # the max time to wait for a task to finish, if unfinished after max_update_hours, the task will be mark as error, but the task will continue to run, default value is 24
                max_update_hours: 24
                # the max time for execution in running state without new task created
                max_dangling_hours: 168
              # Secret is used when job service communicates with other components.
              # If a secret key is not specified, Helm will generate one.
              # Must be a string of 16 chars.
              secret: ""
              # Use an existing secret resource
              existingSecret: "harbor-admin-credentials"
              # Key within the existing secret for the job service secret
              existingSecretKey: JOBSERVICE_SECRET
            ################################################################################
            #  ____            _     _
            # |  _ \ ___  __ _(_)___| |_ _ __ _   _
            # | |_) / _ \/ _` | / __| __| '__| | | |
            # |  _ <  __/ (_| | \__ \ |_| |  | |_| |
            # |_| \_\___|\__, |_|___/\__|_|   \__, |
            #            |___/                |___/
            ################################################################################
            registry:
              registry:
                image:
                  repository: goharbor/registry-photon
                  tag: dev
                # resources:
                #  requests:
                #    memory: 256Mi
                #    cpu: 100m
                extraEnvVars: []
              controller:
                image:
                  repository: goharbor/harbor-registryctl
                  tag: dev
                # resources:
                #  requests:
                #    memory: 256Mi
                #    cpu: 100m
                extraEnvVars: []
              # set the service account to be used, default if left empty
              serviceAccountName: ""
              # mount the service account token
              automountServiceAccountToken: false
              replicas: 1
              revisionHistoryLimit: 10
              nodeSelector: {}
              tolerations: []
              affinity: {}
              # Spread Pods across failure-domains like regions, availability zones or nodes
              topologySpreadConstraints: []
              # - maxSkew: 1
              #   topologyKey: topology.kubernetes.io/zone
              #   nodeTaintsPolicy: Honor
              #   whenUnsatisfiable: DoNotSchedule
              ## Additional deployment annotations
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
              ## The priority class to run the pod as
              priorityClassName:
              # containers to be run before the controller's container starts.
              initContainers: []
              # If a secret key is not specified, Helm will generate one.
              # Must be a string of 16 chars.
              secret: ""
              # Use an existing secret resource
              existingSecret: ""
              # Key within the existing secret for the registry service secret
              existingSecretKey: REGISTRY_HTTP_SECRET
              # If true, the registry returns relative URLs in Location headers. The client is responsible for resolving the correct URL.
              relativeurls: true
              credentials:
                username: "harbor_registry_user"
                password: "harbor_registry_password"
                # If using existingSecret, the key must be REGISTRY_PASSWD and REGISTRY_HTPASSWD
                existingSecret: ""
                # Login and password in htpasswd string format. Excludes `registry.credentials.username`  and `registry.credentials.password`. May come in handy when integrating with tools like argocd or flux. This allows the same line to be generated each time the template is rendered, instead of the `htpasswd` function from helm, which generates different lines each time because of the salt.
                # htpasswdString: $apr1$XLefHzeG$Xl4.s00sMSCCcMyJljSZb0 # example string
              #  htpasswdString: ""
              middleware:
                enabled: false
                type: cloudFront
                cloudFront:
                  baseurl: example.cloudfront.net
                  keypairid: KEYPAIRID
                  duration: 3000s
                  ipfilteredby: none
                  # The secret key that should be present is CLOUDFRONT_KEY_DATA, which should be the encoded private key
                  # that allows access to CloudFront
                  privateKeySecret: "my-secret"
              # enable purge _upload directories
              upload_purging:
                enabled: true
                # remove files in _upload directories which exist for a period of time, default is one week.
                age: 168h
                # the interval of the purge operations
                interval: 24h
                dryrun: false
            ################################################################################
            #  _____     _
            # |_   _| __(_)_   ___   _
            #   | || '__| \ \ / / | | |
            #   | || |  | |\ V /| |_| |
            #   |_||_|  |_| \_/  \__, |
            #                    |___/
            ################################################################################
            trivy:
              # enabled the flag to enable Trivy scanner
              enabled: true
              ## @param trivy.existingEnvVarsSecret Existing secret for trivy
              ## The secret must contain the keys:
              ## `SCANNER_TRIVY_GITHUB_TOKEN` (optional)
              ## `SCANNER_REDIS_URL` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/5")
              ## `SCANNER_STORE_REDIS_URL` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/5")
              ## `SCANNER_JOB_QUEUE_REDIS_URL` (required - if using the internal Redis - set to base64 of "redis://harbor-redis-master:6379/5")
              ##
              existingEnvVarsSecret: ""
              image:
                # repository the repository for Trivy adapter image
                repository: goharbor/trivy-adapter-photon
                # tag the tag for Trivy adapter image
                tag: dev
            ################################################################################
            #  ____        _        _
            # |  _ \  __ _| |_ __ _| |__   __ _ ___  ___
            # | | | |/ _` | __/ _` | '_ \ / _` / __|/ _ \
            # | |_| | (_| | || (_| | |_) | (_| \__ \  __/
            # |____/ \__,_|\__\__,_|_.__/ \__,_|___/\___|
            ################################################################################
            database:
              # if external database is used, set "type" to "external"
              # and fill the connection information in "external" section
              type: external
              internal:
                image:
                  repository: goharbor/harbor-db
                  tag: dev
                # set the service account to be used, default if left empty
                serviceAccountName: ""
                # mount the service account token
                automountServiceAccountToken: false
                livenessProbe:
                  timeoutSeconds: 1
                # The timeout used in readinessProbe; 1 to 5 seconds
                readinessProbe:
                  timeoutSeconds: 1
                extraEnvVars: []
                nodeSelector: {}
                tolerations: []
                affinity: {}
                ## The priority class to run the pod as
                priorityClassName:
                # containers to be run before the controller's container starts.
                extrInitContainers: []
                # The initial superuser password for internal database
                password: "changeit"
                # The size limit for Shared memory, pgSQL use it for shared_buffer
                # More details see:
                # https://github.com/goharbor/harbor/issues/15034
                shmSizeLimit: 512Mi
                initContainer:
                  migrator: {}
                  permissions: {}
              external:
                host: "harbor-postgres-rw.harbor.svc.cluster.local"
                port: "5432"
                username: "harbor"
                password: "password"
                coreDatabase: "harbor"
                # if using existing secret, the key must be "password"
                existingSecret: "harbor-pgsql-credentials"
                # "disable" - No SSL
                # "require" - Always SSL (skip verification)
                # "verify-ca" - Always SSL (verify that the certificate presented by the
                # server was signed by a trusted CA)
                # "verify-full" - Always SSL (verify that the certification presented by the
                # server was signed by a trusted CA and the server host name matches the one
                # in the certificate)
                sslmode: "disable"
              # The maximum number of connections in the idle connection pool per pod (core+exporter).
              # If it <=0, no idle connections are retained.
              maxIdleConns: 100
              # The maximum number of open connections to the database per pod (core+exporter).
              # If it <= 0, then there is no limit on the number of open connections.
              # Note: the default number of connections is 1024 for harbor's postgres.
              maxOpenConns: 900
              ## Additional deployment annotations
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
            ################################################################################
            #  ____          _ _
            # |  _ \ ___  __| (_)___
            # | |_) / _ \/ _` | / __|
            # |  _ <  __/ (_| | \__ \
            # |_| \_\___|\__,_|_|___/
            ################################################################################
            redis:
              # if external Redis is used, set "type" to "external"
              # and fill the connection information in "external" section
              type: external
              internal:
                image:
                  repository: goharbor/redis-photon
                  tag: dev
                # set the service account to be used, default if left empty
                serviceAccountName: ""
                # mount the service account token
                automountServiceAccountToken: false
                # resources:
                #  requests:
                #    memory: 256Mi
                #    cpu: 100m
                extraEnvVars: []
                nodeSelector: {}
                tolerations: []
                affinity: {}
                ## The priority class to run the pod as
                priorityClassName:
                # containers to be run before the controller's container starts.
                initContainers: []
                # Example:
                #
                # - name: wait
                #   image: busybox
                #   command: [ 'sh', '-c', "sleep 20" ]
                # # jobserviceDatabaseIndex defaults to "1"
                # # registryDatabaseIndex defaults to "2"
                # # trivyAdapterIndex defaults to "5"
                # # harborDatabaseIndex defaults to "0", but it can be configured to "6", this config is optional
                # # cacheLayerDatabaseIndex defaults to "0", but it can be configured to "7", this config is optional
                jobserviceDatabaseIndex: "1"
                registryDatabaseIndex: "2"
                trivyAdapterIndex: "5"
                # harborDatabaseIndex: "6"
                # cacheLayerDatabaseIndex: "7"
              external:
                # support redis, redis+sentinel
                # addr for redis: <host_redis>:<port_redis>
                # addr for redis+sentinel: <host_sentinel1>:<port_sentinel1>,<host_sentinel2>:<port_sentinel2>,<host_sentinel3>:<port_sentinel3>
                addr: "valkey-harbor-primary.harbor.svc.cluster.local:6379"
                # The name of the set of Redis instances to monitor, it must be set to support redis+sentinel
                sentinelMasterSet: ""
                # TLS configuration for redis connection
                # only server-authentication is supported, mTLS for redis connection is not supported
                # tls connection will be disable by default
                # Once `tlsOptions.enable` set as true, tls/ssl connection will be used for redis
                # Please set the `caBundleSecretName` in this configuration file which conatins redis server rootCA if it is self-signed.
                # The secret must contain keys named "ca.crt" which will be injected into the trust store
                tlsOptions:
                  enable: false
                # The "coreDatabaseIndex" must be "0" as the library Harbor
                # used doesn't support configuring it
                # harborDatabaseIndex defaults to "0", but it can be configured to "6", this config is optional
                # cacheLayerDatabaseIndex defaults to "0", but it can be configured to "7", this config is optional
                coreDatabaseIndex: "0"
                jobserviceDatabaseIndex: "1"
                registryDatabaseIndex: "2"
                trivyAdapterIndex: "5"
                # harborDatabaseIndex: "6"
                # cacheLayerDatabaseIndex: "7"
                # username field can be an empty string, and it will be authenticated against the default user
                username: ""
                password: ""
                # If using existingSecret, the key must be REDIS_PASSWORD, if ACL mode enabled, also inlcudes data of username, the keys must be REDIS_USERNAME
                existingSecret: ""
              ## Additional deployment annotations
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
            ################################################################################
            #  _____                       _
            # | ____|_  ___ __   ___  _ __| |_ ___ _ __
            # |  _| \ \/ / '_ \ / _ \| '__| __/ _ \ '__|
            # | |___ >  <| |_) | (_) | |  | ||  __/ |
            # |_____/_/\_\ .__/ \___/|_|   \__\___|_|
            #            |_|
            ################################################################################
            exporter:
              image:
                repository: goharbor/harbor-exporter
                tag: dev
              serviceAccountName: ""
              # mount the service account token
              automountServiceAccountToken: false
              replicas: 1
              revisionHistoryLimit: 10
              # resources:
              #  requests:
              #    memory: 256Mi
              #    cpu: 100m
              extraEnvVars: []
              podAnnotations: {}
              ## Additional deployment labels
              podLabels: {}
              nodeSelector: {}
              tolerations: []
              affinity: {}
              # Spread Pods across failure-domains like regions, availability zones or nodes
              topologySpreadConstraints: []
              ## The priority class to run the pod as
              priorityClassName:
              # - maxSkew: 1
              #   topologyKey: topology.kubernetes.io/zone
              #   nodeTaintsPolicy: Honor
              #   whenUnsatisfiable: DoNotSchedule
              cacheDuration: 23
              cacheCleanInterval: 14400
            ################################################################################
            #  __  __      _        _
            # |  \/  | ___| |_ _ __(_) ___ ___
            # | |\/| |/ _ \ __| '__| |/ __/ __|
            # | |  | |  __/ |_| |  | | (__\__ \
            # |_|  |_|\___|\__|_|  |_|\___|___/
            #
            ################################################################################
            metrics:
              enabled: true
              core:
                path: /metrics
                port: 8001
              registry:
                path: /metrics
                port: 8001
              jobservice:
                path: /metrics
                port: 8001
              exporter:
                path: /metrics
                port: 8001
              ## Create prometheus serviceMonitor to scrape harbor metrics.
              ## This requires the monitoring.coreos.com/v1 CRD. Please see
              ## https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/user-guides/getting-started.md
              ##
              serviceMonitor:
                enabled: true
            ################################################################################
            #   ____           _
            #  / ___|__ _  ___| |__   ___
            # | |   / _` |/ __| '_ \ / _ \
            # | |__| (_| | (__| | | |  __/
            #  \____\__,_|\___|_| |_|\___|
            #
            ################################################################################
            # cache layer configurations
            # if this feature enabled, harbor will cache the resource
            # `project/project_metadata/repository/artifact/manifest` in the redis
            # which help to improve the performance of high concurrent pulling manifest.
            cache:
              # default is not enabled.
              enabled: true
              # default keep cache for one day.
              expireHours: 24
            ################################################################################
            #  _____
            # |_   _| __ __ _  ___ ___
            #   | || '__/ _` |/ __/ _ \
            #   | || | | (_| | (_|  __/
            #   |_||_|  \__,_|\___\___|
            #
            ################################################################################
            trace:
              enabled: false
              # trace provider: jaeger or otel
              # jaeger should be 1.26+
              provider: otel
              # set sample_rate to 1 if you wanna sampling 100% of trace data; set 0.5 if you wanna sampling 50% of trace data, and so forth
              sample_rate: 1
              # namespace used to differentiate different harbor services
              # namespace:
              # attributes is a key value dict contains user defined attributes used to initialize trace provider
              # attributes:
              #   application: harbor
              jaeger:
                # jaeger supports two modes:
                #   collector mode(uncomment endpoint and uncomment username, password if needed)
                #   agent mode(uncomment agent_host and agent_port)
                endpoint: http://hostname:14268/
                # username:
                # password:
                # agent_host: hostname
                # export trace data by jaeger.thrift in compact mode
                # agent_port: 6831
              otel:
                endpoint: alloy-metrics.monitoring.svc:4317
                url_path: /v1/traces
                compression: false
                insecure: true
                # timeout is in seconds
                timeout: 10
