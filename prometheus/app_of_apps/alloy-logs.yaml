apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: alloy-logs-appset
  namespace: argocd
spec:
  goTemplate: true
  generators:
    - clusters: {}

  template:
    metadata:
      name: '{{.name}}-alloy-logs'
    spec:
      project: default
      syncPolicy:
        automated:
          selfHeal: true
        syncOptions:
          - ApplyOutOfSyncOnly=true

      destination:
        server: '{{.server}}'
        namespace: monitoring

      source:
        repoURL: 'https://grafana.github.io/helm-charts'
        chart: alloy
        targetRevision: 1.1.1
        helm:
          version: v3
          skipCrds: true
          valuesObject:
            fullnameOverride: alloy-logs

            configReloader:
              enabled: true
              resources:
                requests:
                  cpu: "1m"
                  memory: "5Mi"

            controller:
              type: 'deployment'
              replicas: 1
              parallelRollout: true
              terminationGracePeriodSeconds: null

            tolerations: []

            topologySpreadConstraints: []
            priorityClassName: ''
            podAnnotations: {}
            podLabels: {}
            podDisruptionBudget:
              enabled: false
              minAvailable: null
              maxUnavailable: null

            enableStatefulSetAutoDeletePVC: false

            autoscaling:
              enabled: false

            serviceMonitor:
              enabled: true
              additionalLabels: {}
              interval: ""
              metricRelabelings: {}



            alloy:
              securityContext:
                runAsUser: 0
                runAsGroup: 0
              configMap:
                content: |-
                  logging {
                    level = "debug"
                    format = "logfmt"
                  }

                  livedebugging {
                    enabled = true
                  }

                  discovery.kubernetes "pods" {
                    role = "pod"
                  }

                  discovery.relabel "pod_logs" {
                    targets = discovery.kubernetes.pods.targets

                    rule {
                      source_labels = ["__meta_kubernetes_namespace"]
                      target_label  = "namespace"
                      action        = "replace"
                    }

                    rule {
                      source_labels = ["__meta_kubernetes_pod_name"]
                      action = "replace"
                      target_label = "pod"
                    }

                    rule {
                      source_labels = ["__meta_kubernetes_pod_container_name"]
                      action = "replace"
                      target_label = "container"
                    }

                    rule {
                      source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
                      action = "replace"
                      target_label = "app"
                    }

                    rule {
                      source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
                      action = "replace"
                      target_label = "job"
                      separator = "/"
                      replacement = "$1"
                    }

                    rule {
                      source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
                      action = "replace"
                      target_label = "__path__"
                      separator = "/"
                      replacement = "/var/log/pods/*$1/*.log"
                    }

                    rule {
                      source_labels = ["__meta_kubernetes_pod_container_id"]
                      action = "replace"
                      target_label = "container_runtime"
                      regex = "^(\\S+):\\/\\/.+$"
                      replacement = "$1"
                    }
                  }

                  local.file_match "local_files" {
                    path_targets = [{"__path__" = "/var/log/*.log"}]
                    sync_period = "5s"
                  }

                  loki.source.file "log_scrape" {
                    targets    = local.file_match.local_files.targets
                    forward_to = [loki.process.filter_logs.receiver]
                    tail_from_end = false
                  }

                  loki.process "filter_logs" {
                    stage.drop {
                        source = ""
                        expression  = ".*Connection closed by authenticating user root"
                        drop_counter_reason = "noisy"
                      }
                    forward_to = [loki.write.loki.receiver]
                  }

                  loki.source.kubernetes_events "k8s_events" {
                      forward_to = [loki.write.loki.receiver]
                  }

                  loki.source.kubernetes "pod_logs" {
                    targets    = discovery.relabel.pod_logs.output
                    forward_to = [loki.process.pod_logs.receiver]
                  }

                  loki.process "pod_logs" {
                    stage.static_labels {
                        values = {
                          cluster = "${cluster_name}",
                        }
                    }

                    forward_to = [loki.write.loki.receiver]
                  }

                  loki.write "loki" {
                    endpoint {
                      url = "http://loki-distributed-distributor-headless:3100/loki/api/v1/push"
                    }
                    external_labels = {
                      "clusterName"      = "{{.name}}",
                      "clusterEndpoint"  = "{{.server}}",
                    }
                  }
